###CSRF攻击与防御

####简介
CSRF的全名为Cross-site request forgery，它的中文名为 跨站请求伪造（伪造跨站请求【这样读顺口一点】）
　
CSRF是一种夹持用户在已经登陆的web应用程序上执行非本意的操作的攻击方式。相比于XSS，CSRF是利用了系统对页面浏览器的信任，XSS则利用了系统对用户的信任。

####条件(二者去一不可)
1、客户端必须一个网站并生成cookie凭证存储在浏览器中

2、该cookie没有清除，客户端又tab一个页面进行访问别的网站

####服务器端防御

　　1、重要数据交互采用POST进行接收，当然是用POST也不是万能的，伪造一个form表单即可破解

　　2、使用验证码，只要是涉及到数据交互就先进行验证码验证，这个方法可以完全解决CSRF。但是出于用户体验考虑，网站不能给所有的操作都加上验证码。因此验证码只能作为一种辅助手段，不能作为主要解决方案。

　　3、验证HTTP Referer字段，该字段记录了此次HTTP请求的来源地址，最常见的应用是图片防盗链。PHP中可以采用APache URL重写规则进行防御，

　　4、为每个表单添加令牌token并验证

（可以使用cookie或者session进行构造。当然这个token仅仅只是针对CSRF攻击，在这前提需要解决好XSS攻击，否则这里也将会是白忙一场【XSS可以偷取客户端的cookie】） 
   会有这样的疑问，浏览器本身有同源策略啊，为什么还可以请求其他网站的接口，关键在于浏览器对img，iframe，script中的src是没有同源限制的。

　　CSRF攻击之所以能够成功，是因为攻击者可以伪造用户的请求，该请求中所有的用户验证信息都存在于Cookie中，因此攻击者可以在不知道这些验证信息的情况下直接利用用户自己的Cookie来通过安全验证。由此可知，抵御CSRF攻击的关键在于：在请求中放入攻击者所不能伪造的信息，并且该信息不存在于Cookie之中。

　　鉴于此，我们将为每一个表单生成一个随机数秘钥，并在服务器端建立一个拦截器来验证这个token，如果请求中没有token或者token内容不正确，则认为可能是CSRF攻击而拒绝该请求。

　　由于这个token是随机不可预测的并且是隐藏看不见的，因此恶意攻击者就不能够伪造这个表单进行CSRF攻击了。

　　要求：

　　1、要确保同一页面中每个表单都含有自己唯一的令牌(需要注意用户选项卡式的操作，一个页面打开多个tab)

　　2、验证后需要删除相应的随机数
