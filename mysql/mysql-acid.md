
 **1\. 表锁** 
``` 
   表级锁
   开销小，加锁快，不会出现死锁，锁定颗粒大，发生锁冲突概率高，并发度最低
   行级锁
   开销大，加锁慢，会出现死锁，锁定颗粒小，发生锁冲突概率最低，并发度也最高
   页面锁
   开销界于表锁和行锁中间，会出现死锁，并发度不高
 ```
 **2\. MYisam** 
``` 
myisam的读操作，不会阻塞其它用户对同一表的请求，但会阻塞对同一表的写请求。
myisam的写操作，会阻塞其他用户对同一表的读和写请求。
myisam的读和写之间以及写之间，都是串行的。
当一个线程获得对一个表的写锁后，只有持有锁的线程可以对表进行更新操作，其它线程的读、写操作都会等待，知道锁被释放为止。
答案是写进程先获得锁，不仅如此，即使读进程先请求先到锁等待队列，写请求后到，写锁也会插到读请求之前
 ```
  **3\. InnerDb** 
 ``` 
innerDB和MYIsam的不同在于，具有事物和使用行级锁，并且支持外键，
innerDb是聚集索引，数据文件和索引是绑在一起的，必须要有主键，通过主键索引效率很高，
innerDb不保存具体行数，而myisam有变量单独保存行数的。
InnerDb不支持全文检索，而myisam支持全文索引。
InnerDb的行锁不是绝对的，如果不能确定范围，innerDb也会锁全表。

数据库的隔离级别越严格，并发副作用越小，代价越大，一定程度“串行话”
innerDb自动添加意向排它锁，在insert,update,delete,不需要用户干预。
  ```
  **4\. 并发事物出现的问题，** 
 ``` 
1.更新丢失，当多个事物访问都一行时，然后基于最初选定的值更新该行时，由于每个事物都不知道其它事物的存在，就会发生丢失更新问题，最后的更新覆盖了其它事物所做的更新。
2.脏读， 当一个事物正在修改一条记录，在事物未提交之前这条数据就是不一致数据，另外的事物来获取到这条记录，并进行处理。就会产生脏读
3.不可重复读，当一个事物执行过程中获取了一条记录，两一个记录修改了这条记录，导致再读取这条记录，两次不相同，不能重复读。
4.幻读，一个事物按相同的查询条件重新读取以前检索过的数据,却发现其它事物插入了满足其查询条件，这就是幻读
  ```
**5\. ACID** 
``` 
1.原子性，整个数据库事物是不可分割的工作单位，要不成功，要么失败。
2.一致性，事物开始到结束，数据库的数据完整性没有被破坏，如果每个动作失败，会进行事物回滚，包子数据的一致性。
3.隔离性，多个事物之间的操作是相互分离的
4.持久性，
    innodb_flush_log_at_trx_commit
     默认是1，每个事物都会写入日志并刷新到磁盘，速度最慢，但是最持久
     2，每秒将所有发生的事物写入磁盘然后刷新磁盘
     0，最近一秒所发生的事物日志，写入磁盘，刷新。
```
** 6.总结
事务的实现

 

前面讲的重做日志，回滚日志以及锁技术就是实现事务的基础。


    事务的原子性是通过 undo log 来实现的

    事务的持久性性是通过 redo log 来实现的

    事务的隔离性是通过 (读写锁+MVCC)来实现的

    而事务的终极大 boss 一致性是通过原子性，持久性，隔离性来实现的！！！


原子性，持久性，隔离性折腾半天的目的也是为了保障数据的一致性！

 

总之，ACID只是个概念，事务最终目的是要保障数据的可靠性，一致性。
